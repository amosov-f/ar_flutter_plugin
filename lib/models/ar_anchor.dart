import 'package:ar_flutter_plugin/datatypes/anchor_types.dart';
import 'package:ar_flutter_plugin/utils/json_converters.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/widgets.dart';

/// Object attached to a tracked physical entity of the AR environment (can be initialized with a world transformation)
abstract class ARAnchor {
  ARAnchor({
    required this.type,
    String? name,
  }) : name = name ?? UniqueKey().toString();

  /// Specifies the [AnchorType] of this [ARAnchor]
  final AnchorType type;

  /// Determines the name of the [ARAnchor]
  /// Will be autogenerated if not defined.
  final String name;

  /// Constructs an [ARAnchor] from a serialized anchor object
  factory ARAnchor.fromJson(Map<String, dynamic> arguments) {
    final type = arguments['type'];
    switch (type) {
      case 0: //(= AnchorType.plane)
        return ARPlaneAnchor.fromJson(arguments);
    }
    return ARUnkownAnchor.fromJson(arguments);
  }

  /// Serializes an [ARAnchor]
  Map<String, dynamic> toJson();
}

/// An [ARAnchor] fixed to a tracked plane
class ARPlaneAnchor extends ARAnchor {
  ARPlaneAnchor({
    required this.transformation,
    String? name,
    List<String>? childNodes,
    String? cloudanchorid,
    int? ttl,
  })  : childNodes = childNodes ?? [],
        cloudanchorid = cloudanchorid ?? null,
        ttl = ttl ?? 1,
        super(
            type: AnchorType.plane, name: name);

  /// Defines the anchor’s rotation, translation and scale in world coordinates.
  final Matrix4 transformation;

  /// Names of ARNodes attached to this [APlaneRAnchor]
  List<String> childNodes;

  /// ID associated with the anchor after uploading it to the google cloud anchor API
  String? cloudanchorid;

  /// Time to live of the anchor: Determines how long the anchor is stored once it is uploaded to the google cloud anchor API (optional, defaults to 1 day (24hours))
  int? ttl;

  static ARPlaneAnchor fromJson(Map<String, dynamic> json) =>
      aRPlaneAnchorFromJson(json);

  @override
  Map<String, dynamic> toJson() => aRPlaneAnchorToJson(this);
}

/// Constructs an [ARPlaneAnchor] from a serialized PlaneAnchor object
ARPlaneAnchor aRPlaneAnchorFromJson(Map<String, dynamic> json) {
  return ARPlaneAnchor(
    transformation:
        const MatrixConverter().fromJson(json['transformation'] as List),
    name: json['name'] as String,
    childNodes: json['childNodes']
        ?.map((child) => child.toString())
        ?.toList()
        ?.cast<String>(),
    cloudanchorid: json['cloudanchorid'] as String?,
    ttl: json['ttl'] as int?,
  );
}

/// Serializes an [ARPlaneAnchor]
Map<String, dynamic> aRPlaneAnchorToJson(ARPlaneAnchor instance) {
  return <String, dynamic>{
    'type': instance.type.index,
    'transformation': MatrixConverter().toJson(instance.transformation),
    'name': instance.name,
    'childNodes': instance.childNodes,
    'cloudanchorid': instance.cloudanchorid,
    'ttl': instance.ttl,
  };
}

class ARTerrainAnchor extends ARAnchor {
  final double latitude;
  final double longitude;
  final double altitude;

  ARTerrainAnchor({String? name, required this.latitude, required this.longitude, required this.altitude}) : super(type: AnchorType.terrain, name: name);

  static ARTerrainAnchor fromJson(Map<String, dynamic> json) =>
      aRTerrainAnchorFromJson(json);

  @override
  Map<String, dynamic> toJson() => aRTerrainAnchorToJson(this);
}

ARTerrainAnchor aRTerrainAnchorFromJson(Map<String, dynamic> json) {
  return ARTerrainAnchor(
    name: json['name'] as String,
    latitude: json['latitude'],
    longitude: json['longitude'],
    altitude: json['altitude']
  );
}

Map<String, dynamic> aRTerrainAnchorToJson(ARTerrainAnchor instance) {
  return {
    'type': instance.type.index,
    'name': instance.name,
    'latitude': instance.latitude,
    'longitude': instance.longitude,
    'altitude': instance.altitude,
  };
}

/// An [ARAnchor] type that is not supported yet
class ARUnkownAnchor extends ARAnchor {
  /// Defines the anchor’s rotation, translation and scale in world coordinates.
  final Matrix4 transformation;

  ARUnkownAnchor(
      {required AnchorType type, required this.transformation, String? name})
      : super(type: type, name: name);

  static ARUnkownAnchor fromJson(Map<String, dynamic> json) =>
      aRUnkownAnchorFromJson(json);

  @override
  Map<String, dynamic> toJson() => aRUnkownAnchorToJson(this);
}

ARUnkownAnchor aRUnkownAnchorFromJson(Map<String, dynamic> json) {
  return ARUnkownAnchor(
    type: json['type'],
    transformation:
        const MatrixConverter().fromJson(json['transformation'] as List),
    name: json['name'] as String,
  );
}

Map<String, dynamic> aRUnkownAnchorToJson(ARUnkownAnchor instance) {
  return <String, dynamic>{
    'type': instance.type.index,
    'transformation': MatrixConverter().toJson(instance.transformation),
    'name': instance.name,
  };
}
